"""
Property-Based Tests for BaZi Domain Models.

Uses Hypothesis to generate random inputs and verify that
fundamental BaZi principles hold across ALL possible cases.

These tests verify RELATIONSHIPS and INVARIANTS, not specific values.
"""
import pytest
from hypothesis import given, strategies as st, assume, settings

from bazi.domain.models.elements import (
    WuXing,
    WuXingRelation,
    WangXiang,
    YinYang,
    get_wuxing_relation,
    RELATIONSHIP_WEIGHTS,
)
from bazi.domain.models.stems_branches import (
    HeavenlyStem,
    EarthlyBranch,
    RELATIONS,
)
from bazi.domain.models.pillar import Pillar
from bazi.domain.models.bazi import BaZi
from bazi.domain.services.wuxing_calculator import WuXingCalculator


# =============================================================================
# HYPOTHESIS STRATEGIES - Random BaZi element generators
# =============================================================================

# Basic element strategies
wuxing_strategy = st.sampled_from(list(WuXing))
stem_strategy = st.sampled_from(list(HeavenlyStem))
branch_strategy = st.sampled_from(list(EarthlyBranch))
yinyang_strategy = st.sampled_from(list(YinYang))
wangxiang_strategy = st.sampled_from(list(WangXiang))
relation_strategy = st.sampled_from(list(WuXingRelation))

# Composite strategies
pillar_strategy = st.builds(Pillar, stem=stem_strategy, branch=branch_strategy)


@st.composite
def bazi_strategy(draw):
    """Generate a random valid BaZi chart."""
    year = draw(pillar_strategy)
    month = draw(pillar_strategy)
    day = draw(pillar_strategy)
    hour = draw(pillar_strategy)
    return BaZi(
        year_pillar=year,
        month_pillar=month,
        day_pillar=day,
        hour_pillar=hour,
    )


# =============================================================================
# WUXING CYCLE PROPERTIES
# =============================================================================

class TestWuXingCycleProperties:
    """Properties of the Five Element cycle."""

    @given(element=wuxing_strategy)
    def test_every_element_generates_exactly_one(self, element):
        """Every element generates exactly one other element."""
        generated = element.generates
        assert generated in WuXing
        assert generated != element  # Can't generate self

    @given(element=wuxing_strategy)
    def test_every_element_is_generated_by_exactly_one(self, element):
        """Every element is generated by exactly one other element."""
        generator = element.generated_by
        assert generator in WuXing
        assert generator != element

    @given(element=wuxing_strategy)
    def test_every_element_overcomes_exactly_one(self, element):
        """Every element overcomes exactly one other element."""
        overcome = element.overcomes
        assert overcome in WuXing
        assert overcome != element

    @given(element=wuxing_strategy)
    def test_every_element_is_overcome_by_exactly_one(self, element):
        """Every element is overcome by exactly one other element."""
        overcomer = element.overcome_by
        assert overcomer in WuXing
        assert overcomer != element

    @given(element=wuxing_strategy)
    def test_generation_cycle_is_consistent(self, element):
        """If A generates B, then B is generated by A."""
        generated = element.generates
        assert generated.generated_by == element

    @given(element=wuxing_strategy)
    def test_control_cycle_is_consistent(self, element):
        """If A overcomes B, then B is overcome by A."""
        overcome = element.overcomes
        assert overcome.overcome_by == element

    @given(element=wuxing_strategy)
    def test_five_element_cycle_returns_to_start(self, element):
        """Following generation cycle 5 times returns to start."""
        current = element
        for _ in range(5):
            current = current.generates
        assert current == element

    @given(element=wuxing_strategy)
    def test_five_control_cycle_returns_to_start(self, element):
        """Following control cycle 5 times returns to start."""
        current = element
        for _ in range(5):
            current = current.overcomes
        assert current == element


# =============================================================================
# WUXING RELATION PROPERTIES
# =============================================================================

class TestWuXingRelationProperties:
    """Properties of WuXing relationships."""

    @given(e1=wuxing_strategy, e2=wuxing_strategy)
    def test_every_pair_has_exactly_one_relation(self, e1, e2):
        """For ANY two elements, exactly ONE valid relationship exists."""
        relation = get_wuxing_relation(e1, e2)
        assert relation in WuXingRelation

    @given(element=wuxing_strategy)
    def test_same_element_is_same_relation(self, element):
        """Same element always returns SAME relation."""
        relation = get_wuxing_relation(element, element)
        assert relation == WuXingRelation.SAME

    @given(element=wuxing_strategy)
    def test_generates_relation(self, element):
        """Element to its generated element is I_GENERATE."""
        relation = get_wuxing_relation(element, element.generates)
        assert relation == WuXingRelation.I_GENERATE

    @given(element=wuxing_strategy)
    def test_generated_by_relation(self, element):
        """Element from its generator is GENERATES_ME."""
        relation = get_wuxing_relation(element, element.generated_by)
        assert relation == WuXingRelation.GENERATES_ME

    @given(element=wuxing_strategy)
    def test_overcomes_relation(self, element):
        """Element to what it overcomes is I_OVERCOME."""
        relation = get_wuxing_relation(element, element.overcomes)
        assert relation == WuXingRelation.I_OVERCOME

    @given(element=wuxing_strategy)
    def test_overcome_by_relation(self, element):
        """Element from what overcomes it is OVERCOMES_ME."""
        relation = get_wuxing_relation(element, element.overcome_by)
        assert relation == WuXingRelation.OVERCOMES_ME


# =============================================================================
# RELATIONSHIP WEIGHT PROPERTIES
# =============================================================================

class TestRelationshipWeightProperties:
    """Properties of relationship weights - BaZi strength principles."""

    @given(relation=relation_strategy)
    def test_all_weights_are_positive(self, relation):
        """All relationship weights must be positive."""
        self_val, other_val = RELATIONSHIP_WEIGHTS[relation]
        assert self_val > 0
        assert other_val > 0

    @given(relation=relation_strategy)
    def test_weights_are_tuples_of_two(self, relation):
        """Each weight is a tuple of exactly two values."""
        weight = RELATIONSHIP_WEIGHTS[relation]
        assert len(weight) == 2

    def test_same_element_is_symmetric(self):
        """SAME relationship has equal weights for both sides."""
        self_val, other_val = RELATIONSHIP_WEIGHTS[WuXingRelation.SAME]
        assert self_val == other_val

    def test_same_is_strongest_for_self(self):
        """比和 (SAME) gives highest self_value."""
        same_self, _ = RELATIONSHIP_WEIGHTS[WuXingRelation.SAME]
        for relation in WuXingRelation:
            self_val, _ = RELATIONSHIP_WEIGHTS[relation]
            assert same_self >= self_val

    def test_being_generated_better_than_generating(self):
        """生我 > 我生 for self (receiving is better than giving)."""
        gen_me_self, _ = RELATIONSHIP_WEIGHTS[WuXingRelation.GENERATES_ME]
        i_gen_self, _ = RELATIONSHIP_WEIGHTS[WuXingRelation.I_GENERATE]
        assert gen_me_self > i_gen_self

    def test_controlling_better_than_being_controlled(self):
        """我克 > 克我 for self (controller is stronger)."""
        i_over_self, _ = RELATIONSHIP_WEIGHTS[WuXingRelation.I_OVERCOME]
        over_me_self, _ = RELATIONSHIP_WEIGHTS[WuXingRelation.OVERCOMES_ME]
        assert i_over_self > over_me_self


# =============================================================================
# EARTHLY BRANCH HIDDEN STEMS PROPERTIES
# =============================================================================

class TestHiddenStemsProperties:
    """Properties of 地支藏干 (hidden stems in branches)."""

    @given(branch=branch_strategy)
    def test_every_branch_has_hidden_stems(self, branch):
        """Every earthly branch has at least one hidden stem."""
        assert len(branch.hidden_stems) > 0

    @given(branch=branch_strategy)
    def test_hidden_stems_ratios_sum_to_one(self, branch):
        """藏干比例总和为1 - ratios must sum to 1.0."""
        total = sum(branch.hidden_stems.values())
        assert abs(total - 1.0) < 0.001, f"{branch.chinese}: {total}"

    @given(branch=branch_strategy)
    def test_main_qi_is_dominant(self, branch):
        """本气最强 - main qi (highest ratio) is >= 0.5."""
        max_ratio = max(branch.hidden_stems.values())
        assert max_ratio >= 0.5, f"{branch.chinese} main qi: {max_ratio}"

    @given(branch=branch_strategy)
    def test_all_ratios_are_positive(self, branch):
        """All hidden stem ratios must be positive."""
        for stem, ratio in branch.hidden_stems.items():
            assert ratio > 0, f"{branch.chinese}: {stem.chinese} has ratio {ratio}"

    @given(branch=branch_strategy)
    def test_hidden_stems_are_valid_stems(self, branch):
        """All hidden stems must be valid HeavenlyStem enums."""
        for stem in branch.hidden_stems.keys():
            assert stem in HeavenlyStem


# =============================================================================
# PILLAR PROPERTIES
# =============================================================================

class TestPillarProperties:
    """Properties of 柱 (pillar = stem + branch)."""

    @given(pillar=pillar_strategy)
    def test_pillar_has_valid_stem(self, pillar):
        """Every pillar has a valid heavenly stem."""
        assert pillar.stem in HeavenlyStem

    @given(pillar=pillar_strategy)
    def test_pillar_has_valid_branch(self, pillar):
        """Every pillar has a valid earthly branch."""
        assert pillar.branch in EarthlyBranch

    @given(pillar=pillar_strategy)
    def test_pillar_wuxing_values_are_positive(self, pillar):
        """Pillar relationship values are always positive."""
        stem_val, branch_val = pillar.wuxing_relationship_values()
        assert stem_val > 0
        assert branch_val > 0

    @given(pillar=pillar_strategy)
    def test_pillar_chinese_is_two_chars(self, pillar):
        """Pillar Chinese representation is exactly 2 characters."""
        assert len(pillar.chinese) == 2

    @given(pillar=pillar_strategy)
    def test_pillar_roundtrip_from_chinese(self, pillar):
        """Pillar can be reconstructed from its Chinese form."""
        reconstructed = Pillar.from_chinese(pillar.chinese)
        assert reconstructed.stem == pillar.stem
        assert reconstructed.branch == pillar.branch


# =============================================================================
# BAZI PROPERTIES
# =============================================================================

class TestBaZiProperties:
    """Properties of 八字 (Four Pillars)."""

    @given(bazi=bazi_strategy())
    def test_bazi_has_four_pillars(self, bazi):
        """Every BaZi has exactly four pillars."""
        assert len(bazi.pillars) == 4

    @given(bazi=bazi_strategy())
    def test_bazi_day_master_is_valid_stem(self, bazi):
        """Day master is always a valid heavenly stem."""
        assert bazi.day_master in HeavenlyStem

    @given(bazi=bazi_strategy())
    def test_bazi_day_master_wuxing_is_valid(self, bazi):
        """Day master wuxing is always a valid element."""
        assert bazi.day_master_wuxing in WuXing

    @given(bazi=bazi_strategy())
    def test_bazi_day_master_matches_day_pillar(self, bazi):
        """Day master equals day pillar's stem."""
        assert bazi.day_master == bazi.day_pillar.stem


# =============================================================================
# WUXING CALCULATOR PROPERTIES
# =============================================================================

class TestWuXingCalculatorProperties:
    """Properties of WuXing strength calculations."""

    @given(stem=stem_strategy, branch=branch_strategy)
    def test_relationship_values_are_positive(self, stem, branch):
        """Relationship values are always positive tuples."""
        stem_val, branch_val = WuXingCalculator.get_relationship_values(stem, branch)
        assert stem_val > 0
        assert branch_val > 0

    @given(bazi=bazi_strategy())
    def test_strength_calculation_is_deterministic(self, bazi):
        """Same BaZi always produces same strength result."""
        calc = WuXingCalculator()
        result1 = calc.calculate_strength(bazi)
        result2 = calc.calculate_strength(bazi)

        for element in WuXing:
            assert result1.raw_values[element] == result2.raw_values[element]
            assert result1.adjusted_values[element] == result2.adjusted_values[element]

    @given(bazi=bazi_strategy())
    def test_all_elements_have_non_negative_strength(self, bazi):
        """All element strengths are non-negative."""
        calc = WuXingCalculator()
        result = calc.calculate_strength(bazi)

        for element in WuXing:
            assert result.raw_values[element] >= 0
            assert result.adjusted_values[element] >= 0

    @given(bazi=bazi_strategy())
    def test_strength_result_has_all_five_elements(self, bazi):
        """Strength result contains all five elements."""
        calc = WuXingCalculator()
        result = calc.calculate_strength(bazi)

        assert set(result.raw_values.keys()) == set(WuXing)
        assert set(result.adjusted_values.keys()) == set(WuXing)


# =============================================================================
# SEASONAL WANG XIANG PROPERTIES
# =============================================================================

class TestWangXiangProperties:
    """Properties of 旺相休囚死 (seasonal strength)."""

    @given(phase=wangxiang_strategy)
    def test_all_phases_have_positive_multiplier(self, phase):
        """All phases have positive multipliers."""
        assert phase.multiplier > 0

    def test_wang_xiang_ordering(self):
        """旺 >= 相 >= 休 >= 囚 >= 死."""
        phases = [WangXiang.WANG, WangXiang.XIANG, WangXiang.XIU, WangXiang.QIU, WangXiang.SI]
        for i in range(len(phases) - 1):
            assert phases[i].multiplier >= phases[i + 1].multiplier

    @given(branch=branch_strategy)
    def test_every_season_maps_all_elements(self, branch):
        """Every season has a phase for all five elements."""
        wang_xiang = WuXingCalculator.get_wang_xiang(branch)
        assert set(wang_xiang.keys()) == set(WuXing)

    @given(branch=branch_strategy)
    def test_exactly_one_wang_per_season(self, branch):
        """Each season has exactly one 旺 (prosperous) element."""
        wang_xiang = WuXingCalculator.get_wang_xiang(branch)
        wang_count = sum(1 for phase in wang_xiang.values() if phase == WangXiang.WANG)
        assert wang_count == 1


# =============================================================================
# HARMONY AND CLASH PROPERTIES
# =============================================================================

class TestHarmonyClashProperties:
    """Properties of 合 (harmony) and 冲 (clash) relationships."""

    def test_liu_he_has_six_pairs(self):
        """六合 has exactly 6 harmony pairs."""
        assert len(RELATIONS.LIU_HE) == 6

    def test_wu_he_has_five_pairs(self):
        """五合 has exactly 5 harmony pairs."""
        assert len(RELATIONS.WU_HE) == 5

    def test_zhi_chong_has_six_pairs(self):
        """地支相冲 has exactly 6 clash pairs."""
        assert len(RELATIONS.ZHI_CHONG) == 6

    def test_gan_chong_has_four_pairs(self):
        """天干相冲 has exactly 4 clash pairs."""
        assert len(RELATIONS.GAN_CHONG) == 4

    @given(branch=branch_strategy)
    def test_branch_has_at_most_one_liu_he_partner(self, branch):
        """Each branch has at most one 六合 partner."""
        partners = [
            b2 for b1, b2 in RELATIONS.LIU_HE
            if b1 == branch
        ]
        assert len(partners) <= 1

    @given(branch=branch_strategy)
    def test_branch_has_at_most_one_chong_partner(self, branch):
        """Each branch has at most one 冲 partner."""
        partners = [
            b2 for b1, b2 in RELATIONS.ZHI_CHONG
            if b1 == branch
        ]
        assert len(partners) <= 1
